
{
    var indentStack = [], indent = "";

    function type (name, options) {

        options = options || {};

        var functions = {
            init: options.init || function () {},
            toJS: options.toJS || function () { return '<' + name + '>'; },
        }

        for ( key in options ) {
            functions[key] = options[key];
        }

        type[name] = function () {
            this.nodeType = name;
            functions.init.apply(this, arguments);
        }
        type[name].prototype = functions;
    }

    type('Noop', {
        toJS: function () {
            return '';
        }
    });

    type('Number', {
        init: function (digits) {
            this.value = parseInt(digits.join(''));
        },
        toJS: function () {
            return this.value;
        }
    })

    type('Variable', {
        init: function (name) {
            this.name = name;
        },
        toJS: function () {
            return this.name;
        }
    });

    type('Assignment', {
        init: function(name, value) {
            this.name = name;
            this.value = value;
        },
        toJS: function () {
            return this.name + ' = ' + this.value.toJS() + ';';
        }
    });

    type('Condition', {
        init: function (expr, ifBody, elseBody) {
            this.expression = expr;
            this.ifBody = ifBody;
            this.elseBody = elseBody;
        },
        toJS: function () {
            var out = 'if (' + this.expression.toJS() + ') {\n';
            out += '    ' + this.ifBody.toJS() + '\n';
            out += '}';

            if (this.elseBody) {
                out += ' else {\n';
                out += this.elseBody.toJS() + '\n';
                out += '}';
            }

            return out;
        }
    })

    type('ForLoop', {
        init: function (iterator, item, iterable, body) {
            this.iterator = iterator || 'i';
            this.item = item;
            this.iterable = iterable;
            this.body = body;
        },
        toJS: function () {
            return 'for (var ' + this.iterator + ' = 0; ' + 
                this.iterator + ' < ' + this.iterable.toJS() + '.length; ' + this.iterator + '++) { ' +
                'var ' + this.item + ' = ' + this.iterable.toJS() + '[' + this.iterator + '];\n' +
                this.body.toJS() + '\n' +
                '}';
        }
    });

    type('WhileLoop', {
        init: function (expression, body) {
            this.expression = expression;
            this.body = body;
        },
        toJS: function () {
            return 'while (' + this.expression.toJS() + ') {\n' +
                   this.body.toJS() + '\n' +
                   '}';
        }
    });

    type('Operator', {
        init: function (op, left, right) {
            this.operator = op;
            this.left = left;
            this.right = right;
        },
        toJS: function () {
            return '(' + this.left.toJS() + ' ' + this.operator + ' ' + this.right.toJS() + ')';
        }
    });

    type('ListLiteral', {
        init: function (items) {
            this.items = items;
        },
        toJS: function () {
            var items = this.items.map(function(item) {
                return item.toJS();
            });
            return '[' + items.join(', ') + ']';
        }
    });

    type('ObjectLiteral', {
        init: function () {
            this.keys = [];
            this.values = [];
        },
        add: function (key, value) {
            this.keys.push(key);
            this.values.push(value)
        },
        toJS: function () {
            var out = '{';
            for (var i = 0; i < this.keys.length; i++) {
                out += this.keys[i] + ': ' + this.values[i].toJS();
                if (i < this.keys.length - 1) {
                    out += ', ';
                }
            }
            return out + '}';
        }
    });

    type('LoopControl', {
        init: function (type) {
            this.type = type;
        },
        toJS: function () {
            return this.type + ';';
        }
    });

    type('ImportStatement', {
        init: function (path, name) {
            this.path = path;
            this.name = name || path.split('.')[path.split('.').length-1];
        },
        toJS: function () {
            return ''; // Ignored for now
        }
    });

    type('Literal', {
        init: function (type) {
            this.type = type;
        },
        toJS: function () {
            return this.type;
        }
    });

    type('StringLiteral', {
        init: function (token, string) {
            this.token = token;
            this.string = string.replace(token, '\\' + token);
        },
        toJS: function () {
            return this.token + this.string.split('\n').join('') + this.token;
        }
    });

    type('Block', {
        init: function(statements) {
            this.statements = statements;
        },
        toJS: function () {
            return this.statements.map(function (s) {
                return s.toJS();
            }).join('\n');
        }
    });

}

Program
    = Statement*

Block
    = statements:Statement+
        { return new type.Block(statements) }

Statement 
    = Indent? EOL
        { return new type.Noop(); }

    / Indent a:Assign EOL
        { return a; }

    / Indent a:Expression EOL
        { return a; }

    / Indent 'if ' a:Expression EOL IndentAdd ifBody:Block IndentRemove
      Indent 'else' EOL IndentAdd elseBody:Block IndentRemove 
        { return new type.Condition(a, ifBody, elseBody); }

    / Indent 'if ' a:Expression EOL IndentAdd ifBody:Block IndentRemove
        { return new type.Condition(a, ifBody); }

    / Indent 'for ' iterator:Identifier ', ' item:Identifier ' in ' iterable:Expression EOL IndentAdd body:Block IndentRemove
        { return new type.ForLoop(iterator, item, iterable, body); } 

    / Indent 'for ' item:Identifier ' in ' iterable:Expression EOL IndentAdd body:Block IndentRemove
        { return new type.ForLoop(null, item, iterable, body); } 

    / Indent 'while ' e:Expression EOL IndentAdd body:Block IndentRemove
        { return new type.WhileLoop(e, body); } 

    / Indent word:('break' / 'continue')
        { return new type.LoopControl(word) }

    / Indent 'import ' path:[a-zA-Z.]+ EOL
        { return new type.ImportStatement(path.join('')); }

    / Indent 'import ' path:[a-zA-Z.]+ ' as ' name:Identifier EOL
        { return new type.ImportStatement(path.join(''), name); }

EOL
    = '\r\n' / '\n' / '\r'

Indent
    = i:[ \t]* 
        &{ return i.join("") === indent; }

IndentAdd
    = i:[ \t]+ &{ return i.length > indent.length; }
        { indentStack.push(indent); indent = i.join(""); pos = offset; }

IndentRemove
    = 
        { indent = indentStack.pop(); }

Assign 
    = name:Identifier _ '=' _ value:Expression 
        { return new type.Assignment(name, value) }

Expression 
    = left:Term _ op:[+-] _ right:Expression 
        { return new type.Operator(op, left, right); }
    
    / Term

Term
    = left:Value _ op:[*/] _ right:Term 
        { return new type.Operator(op, left, right); }
    
    / Value

Value
    = Number
    / Literal
    / StringLiteral
    / a:Identifier 
        { return new type.Variable([a]); }

    / '(' _ a:Expression _ ')' 
        { return a; }

    / '[' _ head:Expression? tail:(_ ',' _ Expression)* _ ']'
        { 
            var list = tail.map(function(item) { return item[3]; }); 
            if (head !== '') list.push(head);
            return new type.ListLiteral(list);
        }

    / '{' 
            head:(_ Identifier _ ':' _ Expression)? 
            tail:(_ ',' _ Identifier _ ':' _ Expression)* _  
      '}'
        {
            var obj = new type.ObjectLiteral();
            if (head !== '') obj.add(head[1], head[5]);
            for (var i = 0; i < tail.length; i++) obj.add(tail[i][3], tail[i][7])
            return obj;
        }

Number 
    = Digits:[0-9]+ 
        { return new type.Number(Digits); }

Identifier
    = !ReservedWord a:(Digits / Letters / '_')+ 
        { return a.join(''); }

Digits
    = a:[0-9]+ 
        { return a.join(''); }

Letters
    = a:[a-zA-Z]+ 
        { return a.join(''); }

_
    = [ \t]*

ReservedWord
  = Keyword
  / Literal

Keyword
    = 'break'
    / 'case'
    / 'catch'
    / 'continue'
    / 'debugger'
    / 'default'
    / 'delete'
    / 'do'
    / 'else'
    / 'finally'
    / 'for'
    / 'function'
    / 'if'
    / 'instanceof'
    / 'in'
    / 'new'
    / 'return'
    / 'switch'
    / 'this'
    / 'throw'
    / 'try'
    / 'typeof'
    / 'var'
    / 'void'
    / 'while'
    / 'with' 
    / 'class'
    / 'const'
    / 'enum'
    / 'export'
    / 'extends'
    / 'import'
    / 'super'

Literal
    = word:('null' / 'true' / 'false')
        { return new type.Literal(word); }


StringLiteral "string"
  = parts:('"' DoubleStringCharacters? '"' / "'" SingleStringCharacters? "'") {
      return new type.StringLiteral(parts[0], parts[1]);
    }

DoubleStringCharacters
  = chars:DoubleStringCharacter+ { return chars.join(""); }

SingleStringCharacters
  = chars:SingleStringCharacter+ { return chars.join(""); }

DoubleStringCharacter
  = !('"' / "\\") char_:.        { return char_;     }
  / "\\" sequence:EscapeSequence { return sequence;  }

SingleStringCharacter
  = !("'" / "\\") char_:.        { return char_;     }
  / "\\" sequence:EscapeSequence { return sequence;  }

EscapeSequence
  = SingleEscapeCharacter
  / NonEscapeCharacter

SingleEscapeCharacter
  = ['"]

NonEscapeCharacter
  = (!SingleEscapeCharacter / EOL) char_:. { return char_; }