
{
    var indentStack = [], indent = "";

    function Noop() {
        this.nodeType = 'Noop';
    }

    function Number(digits) {
        this.nodeType = 'Number';
        this.value = parseInt(digits.join(''));
    }

    function Expression (children) {
        this.nodeType = 'Expression'
        this.children = children;
    }

    function Assignment (name, value) {
        this.nodeType = 'Assignment';
        this.name = name;
        this.value = value;
    }

    function Condition (expr, ifBody, elseBody) {
        this.nodeType = 'Condition';
        this.expression = expr;
        this.ifBody = ifBody;
        this.elseBody = elseBody;
    }

    function ForLoop (iterator, item, iterable, body) {
        this.nodeType = 'For';
        this.iterator = iterator;
        this.item = item;
        this.iterable = iterable;
        this.body = body;
    }

    function WhileLoop (expression, body) {
        this.nodeType = 'WhileLoop';
        this.expression = expression;
        this.body = body;
    }

    function Operator (op, left, right) {
        this.nodeType = 'Operator';
        this.operator = op;
        this.left = left;
        this.right = right;
    }

    function ListLiteral (items) {
        this.nodeType = 'List';
        this.items = items;
    }

    function ObjectLiteral () {
        this.nodeType = 'Object';
        this.keys = [];
        this.values = [];
        this.add = function (key, value) {
            this.keys.push(key);
            this.values.push(value)
        }
    }

    function LoopControl (type) {
        this.nodeType = 'LoopControl';
        this.type = type;
    }

    function ImportStatement(path, name) {
        this.nodeType = 'Import';
        this.path = path;
        this.name = name || path.split('.')[path.split('.').length-1];
    }

    function Literal(type) {
        this.nodeType = 'Literal';
        this.type = type;
    }

}

Program
    = Statement*

Statement 
    = Indent? EOL
        { return new Noop(); }

    / Indent a:Assign EOL
        { return a; }

    / Indent a:Expression EOL
        { return a; }

    / Indent 'if ' a:Expression EOL IndentAdd ifBody:Statement+ IndentRemove
      Indent 'else' EOL IndentAdd elseBody:Statement+ IndentRemove 
        { return new Condition(a, ifBody, elseBody); }

    / Indent 'if ' a:Expression EOL IndentAdd ifBody:Statement+ IndentRemove
        { return new Condition(a, ifBody); }

    / Indent 'for ' iterator:Identifier ', ' item:Identifier ' in ' iterable:Expression EOL IndentAdd body:Statement+ IndentRemove
        { return new ForLoop(iterator, item, iterable, body); } 

    / Indent 'for ' item:Identifier ' in ' iterable:Expression EOL IndentAdd body:Statement+ IndentRemove
        { return new ForLoop(null, item, iterable, body); } 

    / Indent 'while ' e:Expression EOL IndentAdd body:Statement+ IndentRemove
        { return new WhileLoop(e, body); } 

    / Indent type:('break' / 'continue')
        { return new LoopControl(type) }

    / Indent 'import ' path:[a-zA-Z.]+ EOL
        { return new ImportStatement(path.join('')); }

    / Indent 'import ' path:[a-zA-Z.]+ ' as ' name:Identifier EOL
        { return new ImportStatement(path.join(''), name); }

EOL
    = '\r\n' / '\n' / '\r'

Indent
    = i:[ \t]* 
        &{ return i.join("") === indent; }

IndentAdd
    = i:[ \t]+ &{ return i.length > indent.length; }
        { indentStack.push(indent); indent = i.join(""); pos = offset; }

IndentRemove
    = 
        { indent = indentStack.pop(); }

Assign 
    = name:Identifier _ '=' _ value:Expression 
        { return new Assignment(name, value) }

Expression 
    = left:Term _ op:[+-] _ right:Expression 
        { return new Operator(op, left, right); }
    
    / Term

Term
    = left:Value _ op:[*/] _ right:Term 
        { return new Operator(op, left, right); }
    
    / Value

Value
    = Number
    / Literal
    / StringLiteral
    / a:Identifier 
        { return new Expression([a]); }

    / '(' _ a:Expression _ ')' 
        { return a; }

    / '[' _ head:Expression? tail:(_ ',' _ Expression)* _ ']'
        { 
            var list = tail.map(function(item) { return item[3]; }); 
            if (head !== '') list.push(head);
            return new ListLiteral(list);
        }

    / '{' 
            head:(_ Identifier _ ':' _ Expression)? 
            tail:(_ ',' _ Identifier _ ':' _ Expression)* _  
      '}'
        {
            var obj = new ObjectLiteral();
            if (head !== '') obj.add(head[1], head[5]);
            for (var i = 0; i < tail.length; i++) obj.add(tail[i][3], tail[i][7])
            return obj;
        }

Number 
    = Digits:[0-9]+ 
        { return new Number(Digits); }

Identifier
    = !ReservedWord a:(Digits / Letters / '_')+ 
        { return a.join(''); }

Digits
    = a:[0-9]+ 
        { return a.join(''); }

Letters
    = a:[a-zA-Z]+ 
        { return a.join(''); }

_
    = [ \t]*

ReservedWord
  = Keyword
  / Literal

Keyword
    = 'break'
    / 'case'
    / 'catch'
    / 'continue'
    / 'debugger'
    / 'default'
    / 'delete'
    / 'do'
    / 'else'
    / 'finally'
    / 'for'
    / 'function'
    / 'if'
    / 'instanceof'
    / 'in'
    / 'new'
    / 'return'
    / 'switch'
    / 'this'
    / 'throw'
    / 'try'
    / 'typeof'
    / 'var'
    / 'void'
    / 'while'
    / 'with' 
    / 'class'
    / 'const'
    / 'enum'
    / 'export'
    / 'extends'
    / 'import'
    / 'super'

Literal
    = type:('null' / 'true' / 'false')
        { return new Literal(type); }


StringLiteral "string"
  = parts:('"' DoubleStringCharacters? '"' / "'" SingleStringCharacters? "'") {
      return parts[1];
    }

DoubleStringCharacters
  = chars:DoubleStringCharacter+ { return chars.join(""); }

SingleStringCharacters
  = chars:SingleStringCharacter+ { return chars.join(""); }

DoubleStringCharacter
  = !('"' / "\\") char_:.        { return char_;     }
  / "\\" sequence:EscapeSequence { return sequence;  }

SingleStringCharacter
  = !("'" / "\\") char_:.        { return char_;     }
  / "\\" sequence:EscapeSequence { return sequence;  }

EscapeSequence
  = SingleEscapeCharacter
  / NonEscapeCharacter

SingleEscapeCharacter
  = ['"]

NonEscapeCharacter
  = (!SingleEscapeCharacter / EOL) char_:. { return char_; }