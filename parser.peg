
{
    var indentStack = [], indent = "";

    function type (name, options) {

        options = options || {};

        var functions = {
            init: options.init || function () {},
            toJS: options.toJS || function () { return '<' + name + '>'; },
        }

        for ( key in options ) {
            functions[key] = options[key];
        }

        type[name] = function () {
            this.nodeType = name;
            functions.init.apply(this, arguments);
        }
        type[name].prototype = functions;
    }

    type('Noop', {
        toJS: function () {
            return '';
        }
    });

    type('Number', {
        init: function (digits) {
            this.value = parseInt(digits.join(''));
        },
        toJS: function () {
            return this.value;
        }
    })

    type('Variable', {
        init: function (name) {
            this.name = name;
        },
        toJS: function () {
            return this.name;
        }
    });

    type('Assignment', {
        init: function(operator, name, value) {
            this.operator = operator;
            this.name = name;
            this.value = value;
        },
        toJS: function () {
            return this.name + ' ' + this.operator + ' ' + this.value.toJS() + ';';
        }
    });

    type('Condition', {
        init: function (expr, ifBody, elseBody) {
            this.expression = expr;
            this.ifBody = ifBody;
            this.elseBody = elseBody;
        },
        toJS: function () {
            var out = 'if (' + this.expression.toJS() + ') {\n';
            out += '    ' + this.ifBody.toJS() + '\n';
            out += '}';

            if (this.elseBody) {
                out += ' else {\n';
                out += this.elseBody.toJS() + '\n';
                out += '}';
            }

            return out;
        }
    })

    type('ForLoop', {
        init: function (iterator, item, iterable, body) {
            this.iterator = iterator || 'i';
            this.item = item;
            this.iterable = iterable;
            this.body = body;
        },
        toJS: function () {
            return 'for (var ' + this.iterator + ' = 0; ' + 
                this.iterator + ' < ' + this.iterable.toJS() + '.length; ' + this.iterator + '++) { ' +
                'var ' + this.item + ' = ' + this.iterable.toJS() + '[' + this.iterator + '];\n' +
                this.body.toJS() + '\n' +
                '}';
        }
    });

    type('WhileLoop', {
        init: function (expression, body) {
            this.expression = expression;
            this.body = body;
        },
        toJS: function () {
            return 'while (' + this.expression.toJS() + ') {\n' +
                   this.body.toJS() + '\n' +
                   '}';
        }
    });

    type('Operator', {
        init: function (op, left, right) {

            this.operator = op === '==' ? '===' : 
                            op === 'and' ? '&&' : 
                            op === 'or' ? '||' : op;
                            
            this.left = left;
            this.right = right;
        },
        toJS: function () {
            return this.left.toJS() + ' ' + this.operator + ' ' + this.right.toJS();
        }
    });

    type('ListLiteral', {
        init: function (items) {
            this.items = items;
        },
        toJS: function () {
            var items = this.items.map(function(item) {
                return item.toJS();
            });
            return '[' + items.join(', ') + ']';
        }
    });

    type('ObjectLiteral', {
        init: function () {
            this.keys = [];
            this.values = [];
        },
        add: function (key, value) {
            this.keys.push(key);
            this.values.push(value)
        },
        toJS: function () {
            var out = '{';
            for (var i = 0; i < this.keys.length; i++) {
                out += this.keys[i] + ': ' + this.values[i].toJS();
                if (i < this.keys.length - 1) {
                    out += ', ';
                }
            }
            return out + '}';
        }
    });

    type('LoopControl', {
        init: function (type) {
            this.type = type;
        },
        toJS: function () {
            return this.type + ';';
        }
    });

    type('ImportStatement', {
        init: function (path, name) {
            this.path = path;
            this.name = name || path.split('.')[path.split('.').length-1];
        },
        toJS: function () {
            return ''; // Ignored for now
        }
    });

    type('ExportStatement', {
        init: function (ident) {
            this.ident = ident;
        },
        toJS: function () {
            return ''; // Ignored for now
        }
    });

    type('Literal', {
        init: function (type) {
            this.type = type;
        },
        toJS: function () {
            return this.type;
        }
    });

    type('StringLiteral', {
        init: function (token, string) {
            this.token = token;
            this.string = string.replace(token, '\\' + token);
        },
        toJS: function () {
            return this.token + this.string.split('\n').join('') + this.token;
        }
    });

    type('Block', {
        init: function(statements) {
            this.statements = statements;
        },
        toJS: function () {
            return this.statements.map(function (s) {
                return s.toJS();
            }).join('\n');
        }
    });

    type('Group', {
        init: function(expr) {
            this.expr = expr;
        },
        toJS: function () {
            return '(' + this.expr.toJS() + ')';
        }
    });

    type('Function', {
        init: function (params, body) {
            this.params = params;
            this.body = body;
        },
        toJS: function () {
            return 'function(' + this.params.join(', ') + '){' + this.body.toJS() + '}';
        }
    });

    type('Return', {
        init: function (body) {
            this.body = body;
        },
        toJS: function () {
            return 'return ' + this.body.toJS() + ';';
        }
    });

    type('FunctionCall', {
        init: function (expr, args) {
            this.expr = expr.toJS ? expr.toJS() : expr;
            this.args = args;
        },
        toJS: function () {
            return this.expr + '(' + this.args.join(', ') + ')';
        }
    });

    type('PropertyAccess', {
        init: function (value, accessors) {
            this.value = value;
            this.accessors = accessors;
        },
        toJS: function () {

            return this.value.toJS() + this.accessors.map(function(accessor) {
                if (typeof accessor === 'string')
                    return '.' + accessor;
                
                return '[' + accessor.toJS() + ']';
            }).join('');

        }
    });

}

Block
    = statements:(Statement (EOL Indent Statement)*)
        {
            var list = [statements[0]];
            for(var i = 0; i < statements[1].length; i++) list.push(statements[1][i][2]);
            return new type.Block(list) 
        }

Statement

    = 'if ' a:Expression IndentNewline ifBody:Block IndentRemove EOL+
      Indent 'else' IndentNewline elseBody:Block IndentRemove 
        { return new type.Condition(a, ifBody, elseBody); }

    / 'if ' a:Expression IndentNewline ifBody:Block IndentRemove
        { return new type.Condition(a, ifBody); }

    / 'for ' iterator:Identifier ', ' item:Identifier ' in ' iterable:Expression IndentNewline body:Block IndentRemove
        { return new type.ForLoop(iterator, item, iterable, body); } 

    / 'for ' item:Identifier ' in ' iterable:Expression IndentNewline body:Block IndentRemove
        { return new type.ForLoop(null, item, iterable, body); } 

    / 'while ' e:Expression IndentNewline body:Block IndentRemove
        { return new type.WhileLoop(e, body); } 

    / word:('break' / 'continue')
        { return new type.LoopControl(word) }

    / 'import ' path:[a-zA-Z.]+ ' as ' name:Identifier
        { return new type.ImportStatement(path.join(''), name); }

    / 'import ' path:[a-zA-Z.]+
        { return new type.ImportStatement(path.join('')); }

    / 'export ' ident:Identifier
        { return new type.ExportStatement(ident); }

    / 'return ' expr:Expression
        { return new type.Return(expr); }

    / a:Assign
        { return a; }

    / a:Expression
        { return a; }

    / Comment
        { return new type.Noop(); }

    / { return new type.Noop() }

EOL
    = '\r\n' / '\n' / '\r'

Indent
    = i:[ \t]* 
        &{ return i.join("") === indent; }

IndentNewline
    = EOL IndentAdd Indent

IndentAdd
    = i:[ \t]+ &{ return i.length > indent.length; }
        { indentStack.push(indent); indent = i.join(""); pos = offset; }

IndentRemove
    =
        { indent = indentStack.pop(); }

Comment
    = '#' (!EOL .)*

Assign 
    = name:Identifier _ op:AssignmentOperator _ value:Expression 
        { return new type.Assignment(op, name, value) }

AssignmentOperator
    = '=' (!'=') { return '='; }
    / '*='
    / '/='
    / '%='
    / '+='
    / '-='
    / '<<='
    / '>>='
    / '>>>='
    / '&='
    / '^='
    / '|='

BinaryOperator
    = '+'
    / '-'
    / '*'
    / '/'
    
    / '>>'
    / '>>>'
    / '<<'

    / '=='
    / '<='
    / '>='
    / '<'
    / '>'

    / 'and'
    / 'or'
    / 'instanceof'
    / 'in'

//
// Cheat alert: This completely ignores operator presedence for simplicity,
// and will create a wrong ast. However, as long as we do not really
// fiddle with operators, it'll output correct javascript.
//
Expression 
    = left:Value _ op:BinaryOperator _ right:Expression 
        { return new type.Operator(op, left, right); }
    
    / value:Value accessors:(
        '[' __ expr:Expression __ ']' { return expr; }
      / '.' __ expr:Identifier        { return expr; }
    )+
        {
            return new type.PropertyAccess(value, accessors); 
        }
        
    / Value

Value
    = Number
    
    / Literal
    
    / StringLiteral

    / expr:(Identifier / GroupedExpression) '(' args:IdentifierTuple ')'
        { return new type.FunctionCall(expr, args); }

    / a:Identifier 
        { return new type.Variable(a); }

    / '[' __ head:Expression? tail:(__ ',' __ Expression)* __ ','? __ ']'
        { 
            var list = tail.map(function(item) { return item[3]; }); 
            if (head !== '') list.push(head);
            return new type.ListLiteral(list);
        }

    / '{' 
            head:(__ Identifier _ ':' _ Expression)? 
            tail:(_ ',' __ Identifier _ ':' _ Expression)* __ ','? __  
      '}'
        {
            var obj = new type.ObjectLiteral();
            if (head !== '') obj.add(head[1], head[5]);
            for (var i = 0; i < tail.length; i++) obj.add(tail[i][3], tail[i][7])
            return obj;
        }

    / '(' _ params:IdentifierTuple _ ')' _ '->' _ body:Expression
        { return new type.Function(params, new type.Return(body)); }

    / '(' _ params:IdentifierTuple _ ')' _ '->' IndentNewline body:Block IndentRemove
        { return new type.Function(params, body); }

    / GroupedExpression

GroupedExpression
    = '(' __ a:Expression __ ')' 
        { return new type.Group(a); }

Number 
    = digits:[0-9]+ 
        { return new type.Number(digits); }

Identifier
    = !ReservedWord a:(Digits / Letters / '_')+ 
        { return a.join(''); }

IdentifierTuple
    = head:Identifier tail:(_ ',' _ Identifier)* _
        {
            tail = tail.map(function(item) { return item[3]; });
            return [head].concat(tail);
        }
    / { return [] }

Digits
    = a:[0-9]+ 
        { return a.join(''); }

Letters
    = a:[a-zA-Z]+ 
        { return a.join(''); }

_
    = [ \t]*

__ 
    = [ \t\n\r]*

ReservedWord
  = Keyword
  / Literal

Keyword
    = 'break'
    / 'case'
    / 'catch'
    / 'continue'
    / 'debugger'
    / 'default'
    / 'delete'
    / 'do'
    / 'else'
    / 'finally'
    / 'for'
    / 'function'
    / 'if'
    / 'instanceof'
    / 'in'
    / 'new'
    / 'return'
    / 'switch'
    / 'this'
    / 'throw'
    / 'try'
    / 'typeof'
    / 'var'
    / 'void'
    / 'while'
    / 'with' 
    / 'class'
    / 'const'
    / 'enum'
    / 'export'
    / 'extends'
    / 'import'
    / 'super'

Literal
    = word:('null' / 'true' / 'false' / 'undefined' )
        { return new type.Literal(word); }


StringLiteral "string"
  = parts:('"' DoubleStringCharacters? '"' / "'" SingleStringCharacters? "'") {
      return new type.StringLiteral(parts[0], parts[1]);
    }

DoubleStringCharacters
  = chars:DoubleStringCharacter+ { return chars.join(""); }

SingleStringCharacters
  = chars:SingleStringCharacter+ { return chars.join(""); }

DoubleStringCharacter
  = !('"' / "\\") char_:.        { return char_;     }
  / "\\" sequence:EscapeSequence { return sequence;  }

SingleStringCharacter
  = !("'" / "\\") char_:.        { return char_;     }
  / "\\" sequence:EscapeSequence { return sequence;  }

EscapeSequence
  = SingleEscapeCharacter
  / NonEscapeCharacter

SingleEscapeCharacter
  = ['"]

NonEscapeCharacter
  = (!SingleEscapeCharacter / EOL) char_:. { return char_; }