
{
    var indentStack = [], indent = "";

    function Noop() {
        this.nodeType = 'Noop';
    }

    function Number(digits) {
        this.nodeType = 'Number';
        this.value = parseInt(digits.join(''));
    }

    function Expression (children) {
        this.nodeType = 'Expression'
        this.children = children;
    }

    function Assignment (name, value) {
        this.nodeType = 'Assignment';
        this.name = name;
        this.value = value;
    }

    function Condition (expr, ifBody, elseBody) {
        this.nodeType = 'Condition';
        this.expression = expr;
        this.ifBody = ifBody;
        this.elseBody = elseBody;
    }

    function ForLoop (iterator, item, iterable, body) {
        this.nodeType = 'For';
        this.iterator = iterator;
        this.item = item;
        this.iterable = iterable;
        this.body = body;
    }

    function WhileLoop (expression, body) {
        this.nodeType = 'WhileLoop';
        this.expression = expression;
        this.body = body;
    }

    function Operator (op, left, right) {
        this.nodeType = 'Operator';
        this.operator = op;
        this.left = left;
        this.right = right;
    }

    function ListLiteral (items) {
        this.nodeType = 'List';
        this.items = items;
    }

    function ObjectLiteral () {
        this.nodeType = 'Object';
        this.keys = [];
        this.values = [];
        this.add = function (key, value) {
            this.keys.push(key);
            this.values.push(value)
        }
    }

    function LoopControl (type) {
        this.nodeType = 'LoopControl';
        this.type = type;
    }

    function ImportStatement(path, name) {
        this.nodeType = 'Import';
        this.path = path;
        this.name = name || path.split('.')[path.split('.').length-1];
    }

}

program
    = statement*

statement 
    = SAMEDENT? EOL
        { return new Noop(); }

    / SAMEDENT a:assign EOL
        { return a; }

    / SAMEDENT a:expr EOL
        { return a; }

    / SAMEDENT 'if ' a:expr EOL INDENT ifBody:statement+ DEDENT
      SAMEDENT 'else' EOL INDENT elseBody:statement+ DEDENT 
        { return new Condition(a, ifBody, elseBody); }

    / SAMEDENT 'if ' a:expr EOL INDENT ifBody:statement+ DEDENT
        { return new Condition(a, ifBody); }

    / SAMEDENT 'for ' iterator:ident ', ' item:ident ' in ' iterable:expr EOL INDENT body:statement+ DEDENT
        { return new ForLoop(iterator, item, iterable, body); } 

    / SAMEDENT 'for ' item:ident ' in ' iterable:expr EOL INDENT body:statement+ DEDENT
        { return new ForLoop(null, item, iterable, body); } 

    / SAMEDENT 'while ' e:expr EOL INDENT body:statement+ DEDENT
        { return new WhileLoop(e, body); } 

    / SAMEDENT type:('break' / 'continue')
        { return new LoopControl(type) }

    / SAMEDENT 'import ' path:[a-zA-Z.]+ EOL
        { return new ImportStatement(path.join('')); }

    / SAMEDENT 'import ' path:[a-zA-Z.]+ ' as ' name:ident EOL
        { return new ImportStatement(path.join(''), name); }

EOL
    = '\r\n' / '\n' / '\r'

SAMEDENT
    = i:[ \t]* 
        &{ return i.join("") === indent; }

INDENT
    = i:[ \t]+ &{ return i.length > indent.length; }
        { indentStack.push(indent); indent = i.join(""); pos = offset; }

DEDENT
    = 
        { indent = indentStack.pop(); }

assign 
    = name:ident _ '=' _ value:expr 
        { return new Assignment(name, value) }

expr 
    = left:term _ op:[+-] _ right:expr 
        { return new Operator(op, left, right); }
    
    / term

term
    = left:value _ op:[*/] _ right:term 
        { return new Operator(op, left, right); }
    
    / value

value
    = number
    
    / a:ident 
        { return new Expression([a]); }

    / '(' _ a:expr _ ')' 
        { return a; }

    / '[' _ head:expr? tail:(_ ',' _ expr)* _ ']'
        { 
            var list = tail.map(function(item) { return item[3]; }); 
            if (head !== '') list.push(head);
            return new ListLiteral(list);
        }

    / '{' 
            head:(_ ident _ ':' _ expr)? 
            tail:(_ ',' _ ident _ ':' _ expr)* _  
      '}'
        {
            var obj = new ObjectLiteral();
            if (head !== '') obj.add(head[1], head[5]);
            for (var i = 0; i < tail.length; i++) obj.add(tail[i][3], tail[i][7])
            return obj;
        }

number 
    = digits:[0-9]+ 
        { return new Number(digits); }

ident
    = !RESERVED a:(digits / letters / '_')+ 
        { return a.join(''); }

digits
    = a:[0-9]+ 
        { return a.join(''); }

letters
    = a:[a-zA-Z]+ 
        { return a.join(''); }

_
    = [ \t]*

RESERVED
    = 'if' / 'for' / 'while' / 'break' / 'continue' / 'import' / 'function'